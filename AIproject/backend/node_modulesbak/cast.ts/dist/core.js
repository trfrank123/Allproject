"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.id = exports.array = exports.values = exports.literal = exports.date = exports.checkbox = exports.boolean = exports.nullable = exports.optional = exports.object = exports.int = exports.float = exports.number = exports.color = exports.email = exports.url = exports.string = exports.InvalidInputError = void 0;
class InvalidInputError extends TypeError {
    constructor(options) {
        let message = `Invalid `;
        if (options.typePrefix) {
            message += options.typePrefix + ' ';
        }
        message += options.expectedType;
        if (options.name) {
            message += ' ' + JSON.stringify(options.name);
        }
        message += ', ' + options.reason;
        if (options.reasonSuffix) {
            message += ' ' + options.reasonSuffix;
        }
        super(message);
        this.status = 400;
        this.statusCode = 400;
    }
}
exports.InvalidInputError = InvalidInputError;
function toType(input) {
    switch (input) {
        case null:
            return 'null';
        case '':
            return 'empty string';
        case true:
            return 'boolean (true)';
        case false:
            return 'boolean (false)';
    }
    if (Number.isNaN(input)) {
        return 'NaN';
    }
    return typeof input;
}
function string(options = {}) {
    function parse(input, context = {}) {
        let expectedType = context.overrideType || 'string';
        if (options.trim !== false && typeof input === 'string') {
            input = input.trim();
        }
        if (options.nonEmpty) {
            if (!expectedType.startsWith('non-empty ')) {
                expectedType = 'non-empty ' + expectedType;
            }
            if (input === '') {
                throw new InvalidInputError({
                    name: context.name,
                    typePrefix: context.typePrefix,
                    expectedType,
                    reason: 'got empty string',
                    reasonSuffix: context.reasonSuffix,
                });
            }
        }
        if (typeof input === 'number') {
            if (Number.isNaN(input)) {
                throw new InvalidInputError({
                    name: context.name,
                    typePrefix: context.typePrefix,
                    expectedType,
                    reason: 'got NaN',
                    reasonSuffix: context.reasonSuffix,
                });
            }
            input = String(input);
        }
        if (typeof input !== 'string') {
            throw new InvalidInputError({
                name: context.name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'got ' + toType(input),
                reasonSuffix: context.reasonSuffix,
            });
        }
        if (typeof options.minLength === 'number') {
            if (input.length < options.minLength) {
                throw new InvalidInputError({
                    name: context.name,
                    typePrefix: context.typePrefix,
                    expectedType,
                    reason: 'minLength should be ' + options.minLength,
                    reasonSuffix: context.reasonSuffix,
                });
            }
        }
        if (typeof options.maxLength === 'number') {
            if (input.length > options.maxLength) {
                throw new InvalidInputError({
                    name: context.name,
                    typePrefix: context.typePrefix,
                    expectedType,
                    reason: 'maxLength should be ' + options.maxLength,
                    reasonSuffix: context.reasonSuffix,
                });
            }
        }
        if (options.match) {
            if (!options.match.test(input)) {
                throw new InvalidInputError({
                    name: context.name,
                    typePrefix: context.typePrefix,
                    expectedType,
                    reason: 'should match ' + options.match,
                    reasonSuffix: context.reasonSuffix,
                });
            }
        }
        return input;
    }
    return { parse, options };
}
exports.string = string;
let urlRegex = /^(.+?):\/\/(.+?)(\/|$)/;
function url(options = {}) {
    let parser = string(options);
    function parse(input, context = {}) {
        if (!options.nonEmpty && input === '')
            return '';
        let expectedType = context.overrideType || 'url';
        let url = parser.parse(input, Object.assign(Object.assign({}, context), { overrideType: expectedType }));
        let match = url.match(urlRegex);
        if (!match) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'should contains protocol and domain/host',
                reasonSuffix: context.reasonSuffix,
            });
        }
        let protocol = match[1];
        let domain = match[2];
        if (Array.isArray(options.protocols) &&
            !options.protocols.includes(protocol)) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'protocol should be any of ' + JSON.stringify(options.protocols),
                reasonSuffix: context.reasonSuffix,
            });
        }
        if (typeof options.protocol === 'string' && protocol !== options.protocol) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'protocol should be ' + JSON.stringify(options.protocol),
                reasonSuffix: context.reasonSuffix,
            });
        }
        if (typeof options.domain === 'string' && domain !== options.domain) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'domain should be ' + JSON.stringify(options.domain),
                reasonSuffix: context.reasonSuffix,
            });
        }
        return url;
    }
    return { parse, options };
}
exports.url = url;
let emailRegex = /^.+?@(.+)$/;
function email(options = {}) {
    let parser = string(options);
    function parse(input, context = {}) {
        if (!options.nonEmpty && input === '')
            return '';
        let expectedType = context.overrideType || 'email';
        let email = parser.parse(input, Object.assign(Object.assign({}, context), { overrideType: expectedType }));
        let match = email.match(emailRegex);
        if (!match) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'should contains "@" and domain',
                reasonSuffix: context.reasonSuffix,
            });
        }
        let domain = match[1];
        if (typeof options.domain === 'string' && domain !== options.domain) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'domain should be ' + JSON.stringify(options.domain),
                reasonSuffix: context.reasonSuffix,
            });
        }
        return email;
    }
    return { parse, options };
}
exports.email = email;
let colorRegex = /^#[0-9a-f]{6}$/i;
/** @description for parsing <input type="color"> in html form submission */
function color() {
    function parse(input, context = {}) {
        let expectedType = context.overrideType || 'color';
        if (typeof input !== 'string' || !input) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'got ' + toType(input),
                reasonSuffix: context.reasonSuffix,
            });
        }
        if (!input.match(colorRegex)) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'should be in "#rrggbb" hexadecimal format',
                reasonSuffix: context.reasonSuffix,
            });
        }
        return input;
    }
    return { parse };
}
exports.color = color;
function number(options = {}) {
    function parse(input, context = {}) {
        let expectedType = context.overrideType || 'number';
        let type = toType(input);
        if (typeof input === 'string') {
            input = +input;
        }
        if (typeof input !== 'number') {
            throw new InvalidInputError({
                name: context.name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'got ' + type,
                reasonSuffix: context.reasonSuffix,
            });
        }
        if (Number.isNaN(input)) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'got ' + type,
                reasonSuffix: context.reasonSuffix,
            });
        }
        if (typeof options.min === 'number') {
            if (input < options.min) {
                throw new InvalidInputError({
                    name: context.name,
                    typePrefix: context.typePrefix,
                    expectedType,
                    reason: 'min value should be ' + options.min,
                    reasonSuffix: context.reasonSuffix,
                });
            }
        }
        if (typeof options.max === 'number') {
            if (input > options.max) {
                throw new InvalidInputError({
                    name: context.name,
                    typePrefix: context.typePrefix,
                    expectedType,
                    reason: 'max value should be ' + options.max,
                    reasonSuffix: context.reasonSuffix,
                });
            }
        }
        return input;
    }
    return { parse, options };
}
exports.number = number;
function float(options = {}) {
    let parser = number(options);
    function parse(input, context = {}) {
        let value = parser.parse(input, Object.assign(Object.assign({}, context), { overrideType: context.overrideType || 'float' }));
        if (typeof options.toFixed === 'number') {
            value = +value.toFixed(options.toFixed);
        }
        if (typeof options.toPrecision === 'number') {
            value = +value.toPrecision(options.toPrecision);
        }
        return value;
    }
    return { parse, options };
}
exports.float = float;
function int(options = {}) {
    let parseNumber = number(options).parse;
    function parse(input, context = {}) {
        let expectedType = context.overrideType || 'int';
        let value = parseNumber(input, Object.assign(Object.assign({}, context), { overrideType: expectedType }));
        if (Number.isInteger(value)) {
            return value;
        }
        throw new InvalidInputError({
            name: context.name,
            typePrefix: context.typePrefix,
            expectedType,
            reason: 'got floating point number',
            reasonSuffix: context.reasonSuffix,
        });
    }
    return { parse, options };
}
exports.int = int;
function object(options = {}) {
    function parse(input, context = {}) {
        let name = context.name;
        let expectedType = context.overrideType || 'object';
        if (input === null) {
            throw new InvalidInputError({
                name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'got null',
                reasonSuffix: context.reasonSuffix,
            });
        }
        if (typeof input !== 'object') {
            throw new InvalidInputError({
                name,
                typePrefix: context.typePrefix,
                expectedType,
                reason: 'got ' + toType(input),
                reasonSuffix: context.reasonSuffix,
            });
        }
        let object = {};
        for (let key in options) {
            let valueParser = options[key];
            if (!(key in input)) {
                if (isOptional(valueParser)) {
                    continue;
                }
                if (isCheckbox(valueParser)) {
                    object[key] = false;
                    continue;
                }
                throw new InvalidInputError({
                    name,
                    typePrefix: context.typePrefix,
                    expectedType,
                    reason: 'missing ' + JSON.stringify(key),
                    reasonSuffix: context.reasonSuffix,
                });
            }
            let valueInput = input[key];
            let value = valueParser.parse(valueInput, {
                name: name ? name + '.' + key : key,
            });
            object[key] = value;
        }
        return object;
    }
    return { parse, options };
}
exports.object = object;
function optional(parser) {
    return Object.assign(parser, { optional: true });
}
exports.optional = optional;
function isOptional(parser) {
    return parser.optional;
}
function nullable(parser) {
    function parse(input, context = {}) {
        if (input === null)
            return null;
        let typePrefix = context.typePrefix;
        return parser.parse(input, Object.assign(Object.assign({}, context), { typePrefix: typePrefix ? 'nullable ' + typePrefix : 'nullable' }));
    }
    return { parse, parser };
}
exports.nullable = nullable;
function boolean(expectedValue) {
    if (expectedValue !== undefined) {
        expectedValue = !!expectedValue;
    }
    function parse(input, context = {}) {
        let expectedType = context.overrideType ||
            (typeof expectedValue === 'boolean'
                ? `boolean (expect: ${expectedValue})`
                : 'boolean');
        let value = parseBooleanString(input);
        if (typeof expectedValue === 'boolean') {
            if (value !== expectedValue) {
                throw new InvalidInputError({
                    name: context.name,
                    typePrefix: context.typePrefix,
                    expectedType,
                    reason: 'got ' + toType(input),
                    reasonSuffix: context.reasonSuffix,
                });
            }
        }
        return value;
    }
    return { parse, expectedValue };
}
exports.boolean = boolean;
function parseBooleanString(input) {
    if (typeof input === 'string') {
        input = input.trim();
    }
    switch (input) {
        case 'false':
            return false;
        default:
            return !!input;
    }
}
/** @description for parsing <input type="checkbox"> in html form submission */
function checkbox() {
    function parse(input, context = {}) {
        let expectedType = context.overrideType || 'checkbox';
        switch (input) {
            case 'on':
                return true;
            case undefined:
                return false;
            default:
                throw new InvalidInputError({
                    name: context.name,
                    typePrefix: context.typePrefix,
                    expectedType,
                    reason: 'got ' + toType(input),
                    reasonSuffix: context.reasonSuffix,
                });
        }
    }
    return { parse, checkbox: true };
}
exports.checkbox = checkbox;
function isCheckbox(parser) {
    return parser.checkbox;
}
let parseDate = date().parse;
function date(options = {}) {
    function parse(input, context = {}) {
        let expectedType = context.overrideType || 'date';
        function checkDate(value) {
            let time = value.getTime();
            if (Number.isNaN(time)) {
                throw new InvalidInputError({
                    name: context.name,
                    typePrefix: context.typePrefix,
                    expectedType,
                    reason: 'got ' + toType(input),
                    reasonSuffix: context.reasonSuffix,
                });
            }
            let rangeNameSuffix = ' of ' + (context.name || 'date');
            if (options.min !== undefined) {
                let min = parseDate(options.min, {
                    name: 'min value' + rangeNameSuffix,
                }).getTime();
                if (time < min) {
                    throw new InvalidInputError({
                        name: context.name,
                        typePrefix: context.typePrefix,
                        expectedType,
                        reason: 'min value should be ' + JSON.stringify(options.min),
                        reasonSuffix: context.reasonSuffix,
                    });
                }
            }
            if (options.max !== undefined) {
                let max = parseDate(options.max, {
                    name: 'max value' + rangeNameSuffix,
                }).getTime();
                if (time > max) {
                    throw new InvalidInputError({
                        name: context.name,
                        typePrefix: context.typePrefix,
                        expectedType,
                        reason: 'max value should be ' + JSON.stringify(options.max),
                        reasonSuffix: context.reasonSuffix,
                    });
                }
            }
            return value;
        }
        if (input instanceof Date) {
            return checkDate(input);
        }
        if (typeof input === 'number') {
            return checkDate(new Date(input));
        }
        if (typeof input === 'string') {
            return checkDate(new Date(input));
        }
        throw new InvalidInputError({
            name: context.name,
            typePrefix: context.typePrefix,
            expectedType,
            reason: 'got ' + toType(input),
            reasonSuffix: context.reasonSuffix,
        });
    }
    return { parse, options };
}
exports.date = date;
function literal(value) {
    function parse(input, context = {}) {
        if (input === value)
            return value;
        let expectedType = context.overrideType || 'literal ' + JSON.stringify(value);
        throw new InvalidInputError({
            name: context.name,
            typePrefix: context.typePrefix,
            expectedType,
            reason: 'got ' + toType(input),
            reasonSuffix: context.reasonSuffix,
        });
    }
    return { parse, value };
}
exports.literal = literal;
function values(values) {
    function parse(input, context = {}) {
        for (let value of values) {
            if (input === value)
                return value;
        }
        let expectedType = context.overrideType ||
            'enum value of ' + JSON.stringify(context.name || values);
        throw new InvalidInputError({
            name: undefined,
            typePrefix: context.typePrefix,
            expectedType,
            reason: 'got ' + toType(input),
            reasonSuffix: context.reasonSuffix,
        });
    }
    return { parse, values };
}
exports.values = values;
function array(parser, options = {}) {
    function parse(input, context = {}) {
        let { typePrefix, reasonSuffix } = context;
        let expectedType = context.overrideType || 'array';
        if (!Array.isArray(input) && options.maybeSingle) {
            input = [input];
        }
        if (!Array.isArray(input)) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix,
                expectedType,
                reason: 'got ' + toType(input),
                reasonSuffix,
            });
        }
        if (typeof options.minLength === 'number' &&
            input.length < options.minLength) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix,
                expectedType,
                reason: 'minLength should be ' + options.minLength,
                reasonSuffix,
            });
        }
        if (typeof options.maxLength === 'number' &&
            input.length > options.maxLength) {
            throw new InvalidInputError({
                name: context.name,
                typePrefix,
                expectedType,
                reason: 'maxLength should be ' + options.maxLength,
                reasonSuffix,
            });
        }
        let values = [];
        for (let element of input) {
            let value = parser.parse(element, Object.assign(Object.assign({}, context), { typePrefix: concat('array of', typePrefix), reasonSuffix: concat(reasonSuffix, 'in array') }));
            values.push(value);
        }
        return values;
    }
    return { parse, parser, options };
}
exports.array = array;
/**
 * @description for parsing database auto-increment primary key
 */
function id() {
    let parseInt = int({ min: 1 }).parse;
    function parse(input, context = {}) {
        return parseInt(input, Object.assign(Object.assign({}, context), { overrideType: 'id' }));
    }
    return { parse };
}
exports.id = id;
function concat(a, b) {
    if (a && b) {
        return a + ' ' + b;
    }
    return a || b;
}
